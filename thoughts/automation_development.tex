\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}

\usepackage{pgfplots}

\begin{document}

\title{TONES Automation}

\author{anematode}

\maketitle

\section{Who is this intended for?}

It's intended for me. I might read this in a few months because I didn't know what the hell I was doing. Thus, it's written in a somewhat understandable way, but it won't try to explain ideas that aren't a product of this project.

\section{What is Automation?}

Automation should be an abstraction of the mapping from a beat number, $b$, to a value of a certain parameter, $p$. In other words, it tells us what the value of a parameter is at some point in beat space (not in \textit{time}, per se, because that is tempo-dependent.) This is very important in the course of modulating parameters to go with the music, and therefore this part of TONES must be well made, fast, sufficiently generalized, and amenable to easy conversion into Web Audio API format. There will definitely be a disconnect between the mathematical description of automation and its actual implementation, but the former should serve as a helpful guidance.

\section{The Distilled Automation Model}

Define a function $f:\mathbb{R}_{\geq 0}\to \mathbb{R}$, which takes in the time in beats since the start of the automation and outputs the value of the parameter at that beat. $f$ need not be continuous; parameters should be able to change instantaneously (in Web Audio, this will correspond to an instant change between two samples). We model this function as a series of $n$ disjoint (apart from their endpoints) segments $s_1, s_2, \cdots, s_n$ covering $[0, l]$, where $l$ is the length of the automation. The boundaries of these segments are $x_1, x_2, \cdots, x_{n+1}\in \mathbb{R}_{\geq 0}$, so the boundaries of segment $s_i$ are $x_i$ and $x_{i+1}$. Note that $x_1 = 0$ and $x_{n+1}=l$. We should think of these segments as functions; the domain of $s_i$ is $[x_i, x_{i+1}]$, and we define $f$ as the piecewise

$$f(b) = \begin{cases}
s_1(b), x_1 \leq b < x_2 \\
s_2(b), x_2 \leq b < x_3 \\
\cdots \\
s_n(b), x_n \leq b < x_{n+1} \\
s_n(x_{n+1}), x_{n+1} \leq b
\end{cases}.$$

Note that we use $\leq$ for the lower bound and $<$ for the upper bound. This is important in the context of instantaneous changes, which are modeled as segments of length $0$. Furthermore, all $b$ greater than the last separator, $x_{n+1}$, have $f(b) = s_n(x_{n+1})$; in essence, the last otherwise-defined value of $f$. The complete description of $f$ is given by the separators $x_i$, the functions $s_i$, and the number of segments $n$; the separators effectively restrict the domains of $s_i$.

Derived properties of $f(b)$, which will prove useful:

$Dom(f)=[0,\infty)$

$l:=x_{n+1}$, the length of the automation

$pmax:=\max (f)$, the maximum value $f$ attains (more precisely/correctly, the supremum of the image of $f$, because there are cases where $pmax\neq f(a)$ for any $a$ due to a discontinuity)

$pmin:=\min (f)$, the minimum value $f$ attains (more precisely/correctly, the infimum of the image of $f$, because there are cases where $pmin\neq f(a)$ for any $a$ due to a discontinuity)

$Rng(f) \subseteq [pmin, pmax]$. Note that the range can be equal to this interval, or the same interval with open boundaries, or even with gaps in the middle (due to discontinuities).

$derivative(x) := f'(x)$, the derivative of $f$, with domain $Dom(derivative) \subseteq [0, \inf) \backslash \{x_i\} $. Note that $f'(x)$ is undefined if and only if $x\in x_i$ (and $f$ is non-differentiable at $x_i$ because $1<i\leq n \land \lim_{x\to x_i^+} s_{i-1}'(x)\neq \lim_{x\to x_i^-} s_{i}'(x)$ or $i = n+1\land \lim_{x\to x_{n+1}^+} s_n'(x) \neq 0$)

$integral(x) := \int_{0}^{x} f(x) dx$, the definite integral of $f$ from $0$ to $x$, with domain $[0, \inf)$. Because $f$ is defined for all $x\geq 0$, this function should be defined for all $x\geq 0$ as well by the Fundamental Theorem of Calculus

$timeIntegral(x) := \int_{0}^{x} \frac{1}{f(x)} dx$, the definite integral of $1/f$ from $0$ to $x$. This integral should exist iff $pmin>0$, otherwise it's nonsensical for its intended purpose: tempo automations.

Let's see how we'd define an actual automation that highlights some of these properties of $f$.

\tikzset{
  jumpdot/.style={mark=*,solid},
  excl/.append style={jumpdot,fill=white},
  incl/.append style={jumpdot,fill=black},
}

\begin{tikzpicture}
  \begin{axis}[ 
    xlabel=$b$,
    ylabel={$f(b)$}
  ] 
    \addplot[domain=0:1] {0};
    \addplot[domain=1:2] {x-1};
    \addplot[domain=2:3] {x-2};
    \addplot[domain=3:4] {-x+4};
    \addplot[excl] coordinates {(2, 1)};
    \addplot[incl] coordinates {(2, 0)};
    \addplot[excl] coordinates {(4, 0)};
    \addplot[incl] coordinates {(4, 1)};
    
  \end{axis}
\end{tikzpicture}

Obviously, automations will also have non-linear segments, but this is for simplicity. We have $l=4$, $n=5$, $x_i={0, 1, 2, 3, 4, 4}$, and

$$s_i = \{0, x-1, x-2, -x+4, 1\}.$$

Here are some values of $f$, the derivative, and the integral, spaced evenly from $0$ to $5$:

$$f(0) = s_1(0) = 0; integral(0) = 0; derivative(0) = 0$$ [Note that the derivative is defined at $0$ because $\lim_{x\to 0^+} f(x) = 0$]
$$f(.5) = s_1(.5) = 0; integral(.5) = 0; derivative(.5) = 0$$
$$f(1) = s_2(1) = 0; integral(1) = 0; derivative(1) = \text{undef}$$ [$f$ is continuous, but non-differentiable, at $1$]
$$f(1.5) = s_2(1.5) = 0.5; integral(1.5) = 0.125; derivative(1.5) = 1$$
$$f(2) = s_3(2) = 0; integral(2) = 0.5; derivative(2) = \text{undef}$$
$$f(2.5) = s_3(2.5) = 0.5; integral(2.5) = 0.625; derivative(2.5) = 1$$
$$f(3) = s_4(3) = 1; integral(3) = 1; derivative(3) = \text{undef}$$
$$f(3.5) = s_4(3.5) = 0.5; integral(3.5) = 1.375; derivative(3.5) = -1$$
$$f(4) = s_5(4) = 1; integral(4) = 1.5; derivative(4) = \text{undef}$$
$$f(4.5) = s_5(4) = 1; integral(4.5) = 2; derivative(4.5) = 0$$
$$f(5) = s_5(4) = 1; integral(5) = 2.5; derivative(5) = 0.$$

For the case where an instantaneous change occurs in the middle of an automation, note that in this case we would have two consecutive and equal $x_i$: $x_j = x_{j+1}$ for $j<n$. Then, the corresponding segment will have no $x$ values corresponding to it in the piecewise, including $x=x_j$! That's because the domain of $s_j$ will be $x_j \leq x < x_{j+1}$, which has no solutions; instead $x=x_j$ will fall in segment $s_{j+1}$ because that has domain $x_{j+1} \leq x < x_{j+2}$. This is desirable behavior: instantaneous changes will have no effect in the middle of an automation, but they will signal a change in a parameter right at the end of an automation if necessary. This is useful for resetting parameters quickly, for example.

In summary, we can define an mapping $f:\mathbb{R}_{\geq 0}\to \mathbb{R}$ taking in a beat time $b$ and spitting out the value of a parameter at that time, uniquely defined by $n>0$ (number of segments), $s_1, ..., s_n$ (segment functions), and $x_1, \cdots, x_{n+1}$ (domain separators), with certain consequent properties. The rest of this document is about the actual implementation.

\section{AutomationSegment}

A parent, abstract class which all the segment functions will be based on.

Properties:

$x_1$: starting x value ($\geq 0$)

$x_2$: ending x value ($\geq x_1$)

$y_1$: starting y value

$y_2$: ending y value

Functions:

constructor($x_1$, $y_1$, $x_2$, $y_2$): class constructor, rejecting $x_2 < x_1$

length(): returns $x_2 - x_1$

deltaY(): returns $y_2 - y_1$

Children should implement:

ymin(): minimum of the segment over the range $[x_1, x_2]$.

ymax(): maximum of the segment over the range $[x_1, x_2]$.

valueAt(x): returning the value of the segment at beat x. Only has to be valid for the domain $[x_1, x_2]$, but it can be continued to other values if that makes things easier.

derivativeAt(x): returning the value of the derivative at beat x. Similarly, only has to be valid for $[x_1, x_2]$.

integralAt(x): returning the value of $$\int_{x_1}^x s(x) dx;$$ only has to be valid for $[x_1, x_2]$.

timeIntegral(x): returning the value of $$\int_{x_1}^x \frac{1}{s(x)} dx;$$ only has to be valid for $[x_1, x_2]$ and if ymin() $>$ 0.

translateX(x): translate the segment left or right by x units and return itself

translateY(y): translate the segment up or down by y units and return itself

scaleX(x): scale the segment \textbf{relative to 0} in the x-axis and return itself

scaleY(y): scale the segment \textbf{relative to 0} in the y-axis and return itself

clone(): clone the segment

%snip(a, b): return a new segment between a and b with the same values as this segment

\section{ConstantAutomationSegment}

Child of Automation Segment

A constant between $x_1, c$ and $x_2, c$.

Properties (besides parent's):

c: the value of the constant parameter

Functions:

constructor($x_1$, $x_2$, c): calls super($x_1$, c, $x_2$, c)

ymin: c

ymax: c

valueAt(x): c

derivativeAt(x): 0

integralAt(x): $c(x-x_1)$

timeIntegral(x): $(x-x_1)/c$

translateX(x): $x_1:=x+x_1$, $x_2:=x+x_2$

translateY(y): $y_1:=y+y_1$, $y_2:=y+y_2$

scaleX(x): $x_1:=xx_1$, $x_2:=xx_2$; flip $(x_1, y_1)$ and $(x_2, y_2)$ if necessary

scaleY(y): $y_1:=yy_1$, $y_2:=yy_2$

clone(): simply construct the segment with parameters $x_1, y_1, x_2, y_2$.

\section{LinearAutomationSegment}

Child of Automation Segment.

Simple linear interpolation between $(x_1, y_1)$ and $(x_2, y_2)$, which also works for constant values if $y_1=y_2$.

No extra properties.

Functions:

constructor(...args): rejects $x_2 = x_1$, then calls super(...args)

ymin: $\min\{y_1, y_2\}$

ymax: $\max\{y_1, y_2\}$

valueAt(x): $$(x - x_1) \cdot \frac{y_2 - y_1}{x_2 - x_1} + y_1$$

derivativeAt(x): $$\frac{y_2-y_1}{x_2-x_1}$$

Derivation: $$\frac{d}{dx}\left((x - x_1) \cdot \frac{y_2 - y_1}{x_2 - x_1} + y_1\right) = \frac{y_2 - y_1}{x_2 - x_1}$$

integralAt(x): $$y_1(x-x_1) + \frac{m(x-x_1)^2}{2},$$ where $m=\frac{y_2 - y_1}{x_2 - x_1}$ is the slope.

Derivation: If $m=\frac{y_2 - y_1}{x_2 - x_1}$, then $$integralAt(x) = \int_{x_1}^x (t - x_1) \cdot m + y_1 dt = \int_{0}^{x-x_1} mt + y_1 dt.$$ The antiderivative is $bt + \frac{mt^2}{2}$, so the value of the definite integral is

$$\left. y_1t + \frac{mt^2}{2} \right\vert _ {t=0} ^ {t=x-x_1} = \underbrace{y_1(x-x_1)}_{\text{rectangle}} + \underbrace{\frac{m(x-x_1)^2}{2}}_{\text{triangle}}$$

The underbraces are for a sanity check.

timeIntegral(x)= $$\begin{cases}
\frac{\log(m(x-x_1)+y_1)-\log(y_1)}{m}, m\neq 0 \\
\frac{x-x_1}{y_1}, m = 0
\end{cases}$$

Derivation: We have $\int \frac{1}{mx+b} dx = \frac{\log(mx+b)}{m}+C$ if $m\neq 0$, where $\log$ is $\ln$. Of course, we have $b = y_1$ and $m=\frac{y_2 - y_1}{x_2 - x_1}$, so we have

$$\int_{x_1}^x \frac{1}{s(t)} dt = \int_{0}^{x-x_1} \frac{1}{s(t+x_1)} dt = \left. \frac{\log(mt+y_1)}{m} \right\vert _ {t=0}^{t=x-x_1} = \frac{\log(m(x-x_1)+y_1)-\log(y_1)}{m}.$$

If $m=0$, then we're just integrating $1/y_1$ from $x_1$ to $x$, giving $\frac{x-x_1}{y_1}$. In practice, it's probably intelligent to choose some arbitrary $0<\epsilon\ll 1$ and use this second formula for $|m| < \epsilon$, because dividing by very small $m$ is not good float-wise. [TODO] figure out a better way to calculate timeIntegral for very, very small $|m|$.

translateX(x): $x_1:=x+x_1$, $x_2:=x+x_2$

translateY(y): $y_1:=y+y_1$, $y_2:=y+y_2$

scaleX(x): reject $x=0$; $x_1:=xx_1$, $x_2:=xx_2$; flip $(x_1, y_1)$ and $(x_2, y_2)$ if necessary

scaleY(y): $y_1:=yy_1$, $y_2:=yy_2$

clone(): simply construct the segment with parameters $x_1, y_1, x_2, y_2$.


\end{document}